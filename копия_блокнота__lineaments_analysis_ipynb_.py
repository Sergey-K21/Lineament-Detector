# -*- coding: utf-8 -*-
"""Копия блокнота "Lineaments_Analysis.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pT7hVhG69R_l5ZIWdNY-KJpxUHSYfxoE

#Импорты
"""

!pip install rasterio

import geopandas as gpd
import matplotlib.pyplot as plt
import pandas as pd
from shapely.geometry import Point, LineString
import numpy as np
import rasterio
from skimage import filters, feature, morphology, measure
from scipy import ndimage
from rasterio.errors import RasterioIOError
import seaborn as sns

"""# Обработка линеаментов"""

data = gpd.read_file("/content/Слой корректных объектов Sentinel.shp")

from shapely.ops import linemerge, unary_union
from shapely.geometry import MultiLineString, LineString

# Преобразуем GeoSeries в список LineString
lines_list = data.geometry.tolist()

# Объединяем линии
merged_line = linemerge(lines_list)  # -> LINESTRING или MULTILINESTRING

# Создаём новый GeoDataFrame
result_gdf = gpd.GeoDataFrame(geometry=[merged_line], crs=data.crs)

# Разбиваем и создаём новый GeoDataFrame
new_gdf = gpd.GeoDataFrame(geometry=[LineString(part) for part in merged_line.geoms], crs=result_gdf.crs)

new_gdf["length"] = new_gdf.length

new_gdf['length'].describe()

fig, ax = plt.subplots(figsize=(12, 10))
data.plot(ax=ax, color="blue", edgecolor="darkblue", alpha=0.5, label="Разломы")
plt.show()

from shapely.validation import make_valid

def filter_and_visualize_short_lines(input_shapefile, min_length):
    """Фильтрация линий с проверкой CRS и визуализацией."""
    gdf = new_gdf

    # Проверка наличия CRS
    if gdf.crs is None:
        print("⚠️ Внимание: CRS не определен. Предполагается WGS84 (EPSG:4326).")
        gdf = gdf.set_crs("EPSG:4326")  # Устанавливаем CRS

    # Проверка типа геометрии
    if not all(gdf.geometry.type.isin(['LineString', 'MultiLineString'])):
        raise ValueError("Данные должны быть линиями (LineString/MultiLineString).")

    # Преобразование в проекцию (если данные в градусах)
    if gdf.crs.is_geographic:
        print("Преобразование в Web Mercator (EPSG:3857) для расчета длины в метрах...")
        gdf = gdf.to_crs("EPSG:3857")

    # Расчет длины и фильтрация
    gdf['length'] = gdf.geometry.length
    filtered = gdf[gdf.length >= min_length]
    removed = gdf[gdf.length < min_length]

    # Визуализация
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))
    gdf.plot(ax=ax1, color='blue', linewidth=0.7, alpha=0.7)
    filtered.plot(ax=ax2, color='green', linewidth=1.5, alpha=0.7)
    removed.plot(ax=ax2, color='red', linewidth=0.5, linestyle=':', alpha=0.5)

    ax1.set_title(f"Исходные данные ({len(gdf)} линий)")
    ax2.set_title(f"Отфильтровано (min_length={min_length} м)\n"
                 f"Сохранено: {len(filtered)}, Удалено: {len(removed)}")
    plt.show()

    return filtered

lineaments = filter_and_visualize_short_lines(data, min_length=1000)

output_path = "filtered_lin_FABDEM.shp"
lineaments.to_file(output_path, encoding='utf-8')

"""# Метрики оценки кривизны линий и фильтрация по кривизне"""

# 1. Угловая мера (сумма углов поворота).

def calculate_angle(p1, p2, p3):
    """Вычисляет угол между векторами p2p1 и p2p3 в градусах."""
    v1 = np.array(p1) - np.array(p2)
    v2 = np.array(p3) - np.array(p2)
    cosine = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
    angle = np.degrees(np.arccos(np.clip(cosine, -1, 1)))
    return angle

def curvature_angle(linestring):
    """Сумма углов поворота линии."""
    coords = list(linestring.coords)
    total_angle = 0
    for i in range(1, len(coords) - 1):
        p1, p2, p3 = coords[i-1], coords[i], coords[i+1]
        total_angle += calculate_angle(p1, p2, p3)
    return total_angle

# 2. Индекс извилистости (Sinousity Index).

def sinuosity_index(linestring):
    """Вычисляет индекс извилистости."""
    length = linestring.length
    start_end_dist = LineString([linestring.coords[0], linestring.coords[-1]]).length
    return length / start_end_dist if start_end_dist > 0 else 1.0

# 3. Среднее квадратичное отклонение от прямой.

def mean_squared_deviation(linestring):
    """Среднеквадратичное отклонение точек от прямой."""
    coords = np.array(linestring.coords)
    start, end = coords[0], coords[-1]

    # Уравнение прямой: Ax + By + C = 0
    A = end[1] - start[1]
    B = start[0] - end[0]
    C = end[0] * start[1] - start[0] * end[1]

    distances = np.abs(A * coords[:, 0] + B * coords[:, 1] + C) / np.sqrt(A**2 + B**2)
    return np.mean(distances**2)

lineaments["sinuosity"] = lineaments.geometry.apply(sinuosity_index)
lineaments["angle_sum"] = lineaments.geometry.apply(curvature_angle)
lineaments["mse_deviation"] = lineaments.geometry.apply(mean_squared_deviation)

lineaments

lineaments['sinuosity'].describe()

lineaments_new = lineaments[lineaments['sinuosity'] < 1.5]

lineaments_new

output_path_1 = "_lin_smooth_Sentinel.shp"
lineaments_new.to_file(output_path_1, encoding='utf-8')

"""# Поиск трендов в линеаментном поле

"""

gdf_1 = gpd.read_file("/content/lineaments_FABDEM_WinLessa_UVS_3857.shp")

gdf_1['length'].describe()

gdf_2 = gdf_1[gdf_1['length'] > 10000]

gdf_2

from sklearn.cluster import KMeans, DBSCAN
from shapely.geometry import LineString, Point
from scipy.stats import gaussian_kde
from scipy.spatial import cKDTree

def calculate_segment_vectors(line):
    """Вычисляет векторы, длины, углы и середины сегментов линии"""
    coords = np.array(line.coords)
    vectors = coords[1:] - coords[:-1]
    lengths = np.hypot(vectors[:, 0], vectors[:, 1])
    angles = np.degrees(np.arctan2(vectors[:, 1], vectors[:, 0])) % 180
    midpoints = (coords[:-1] + coords[1:]) / 2
    return vectors, lengths, angles, midpoints

def create_trend_lines(midpoints, angles, lengths, densities, clusters, scale=1.0):
    """Создает линии-тренды на основе кластеров направлений"""
    trend_lines = []
    cluster_angles = []

    for cluster_id, center_angle in enumerate(clusters):
        # Фильтруем сегменты, принадлежащие текущему кластеру
        angle_diff = np.abs(angles - center_angle)
        angle_diff = np.minimum(angle_diff, 180 - angle_diff)
        mask = angle_diff < 15  # порог для принадлежности к кластеру

        if not np.any(mask):
            continue

        cluster_midpoints = midpoints[mask]
        cluster_vectors = (np.column_stack([np.cos(np.radians(angles[mask])),
                                         np.sin(np.radians(angles[mask]))]) *
                         lengths[mask, np.newaxis])

        # Усредняем направление с учетом весов (длина × плотность)
        weights = lengths[mask] * densities[mask]
        mean_vector = np.average(cluster_vectors, axis=0, weights=weights)
        mean_angle = np.degrees(np.arctan2(mean_vector[1], mean_vector[0])) % 180

        # Создаем линию-тренд через центр масс сегментов
        center_of_mass = np.average(cluster_midpoints, axis=0, weights=weights)
        trend_length = np.linalg.norm(mean_vector) * scale

        # Создаем линию в усредненном направлении через центр масс
        angle_rad = np.radians(mean_angle)
        dx = trend_length * np.cos(angle_rad)
        dy = trend_length * np.sin(angle_rad)

        trend_line = LineString([
            (center_of_mass[0] - dx/2, center_of_mass[1] - dy/2),
            (center_of_mass[0] + dx/2, center_of_mass[1] + dy/2)
        ])

        trend_lines.append(trend_line)
        cluster_angles.append(mean_angle)

    return gpd.GeoDataFrame(geometry=trend_lines,
                          data={'angle': cluster_angles},
                          crs=gdf.crs)

def plot_results(gdf, trend_gdf, midpoints, densities, clusters):
    """Визуализация исходных линий и выделенных трендов"""
    fig, ax = plt.subplots(figsize=(12, 10))

    # Визуализация исходных линий с цветом по плотности
    gdf.plot(ax=ax, linewidth=0.5, color='gray', alpha=0.3, label='Исходные линии')

    # Визуализация трендов
    colors = plt.cm.tab10(np.linspace(0, 1, len(clusters)))
    for idx, (_, row) in enumerate(trend_gdf.iterrows()):
        ax.plot(*row.geometry.xy, color=colors[idx],
               linewidth=3,
               label=f'Тренд {idx+1}: {row["angle"]:.1f}°')

    # Центры масс кластеров
    ax.scatter(midpoints[:, 0], midpoints[:, 1], c=densities,
              cmap='viridis', s=5, alpha=0.5)

    ax.set_title('Выделение линейных трендов с учетом плотности', fontsize=14)
    ax.legend()
    plt.tight_layout()
    plt.show()

# Основной анализ
def full_analysis(gdf, n_clusters=3, min_length=None, spatial_bandwidth=None):
    # Анализ направлений и плотности
    vectors, lengths, angles, midpoints = [], [], [], []
    for line in gdf.geometry:
        if isinstance(line, LineString):
            v, l, a, m = calculate_segment_vectors(line)
            vectors.extend(v)
            lengths.extend(l)
            angles.extend(a)
            midpoints.extend(m)

    vectors = np.array(vectors)
    lengths = np.array(lengths)
    angles = np.array(angles)
    midpoints = np.array(midpoints)

    # Оценка плотности
    kde = gaussian_kde(midpoints.T, bw_method=spatial_bandwidth)
    densities = kde(midpoints.T)
    densities = densities / densities.max()

    # Кластеризация направлений
    angles_for_clustering = np.concatenate([angles, angles + 180])
    weights = np.concatenate([lengths * densities] * 2)

    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
    kmeans.fit(angles_for_clustering.reshape(-1, 1), sample_weight=weights)
    clusters = kmeans.cluster_centers_.reshape(-1) % 180

    # Создание линий-трендов
    trend_gdf = create_trend_lines(midpoints, angles, lengths, densities, clusters, scale=2.0)

    # Визуализация
    plot_results(gdf, trend_gdf, midpoints, densities, clusters)

    return trend_gdf, clusters

# Пример использования с пространственной плотностью
if __name__ == "__main__":
    gdf = gdf_2

    # Запуск анализа
    trend_gdf, clusters = full_analysis(
        gdf,
        n_clusters=3,
        min_length=50000,
        spatial_bandwidth=0.7
    )

    #print("Основные тренды:")
    #print(trend_gdf[['angle', 'geometry']])

fig, ax = plt.subplots(figsize=(12, 10))
trend_gdf.plot(ax=ax, color="blue", edgecolor="darkblue", alpha=1, label="Разломы")
plt.show()

clusters

"""# Поиск линеаментов"""

rasterio.open('/content/5_5.tif')

with rasterio.open("/content/Sentinel_B6_AOI_Chukotka.tif") as src:
    print("Метаданные:")
    print(src.meta)  # Выводим основные метаданные
    print("\nКоличество каналов:", src.count)
    print("Размеры (ширина, высота):", src.width, src.height)

    # Пробуем прочитать первый канал
    try:
        band1 = src.read(1)  # Читаем первый канал
        print("\nУспешно прочитана матрица размером:", band1.shape)
        print("Пример данных:", band1[100:105, 100:105])  # Выводим небольшой фрагмент
    except Exception as e:
        print("\nОшибка при чтении:", str(e))

dem = band1
dem.shape

height, width = dem.shape
max_width = 10000

if width <= max_width:
    print("Разбиение не требуется")
else:
    # Вычисляем размеры частей
    part_width = width // 3

    if part_width > max_width:
        print(f"Ошибка: требуемая ширина части {part_width} > {max_width}")
    else:
        # Разбиваем массив на части
        part1 = dem[:, 0:part_width]
        part2 = dem[:, part_width:2*part_width]
        part3 = dem[:, 2*part_width:width]

        print("Разбиение завершено:")
        print(f"Часть 1: {part1.shape}")
        print(f"Часть 2: {part2.shape}")
        print(f"Часть 3: {part3.shape}")

        # Теперь вы можете сохранить или обработать части отдельно
        # Например:
        # np.save('part1.npy', part1)
        # np.save('part2.npy', part2)
        # np.save('part3.npy', part3)

part1.shape

plt.imshow(part1)

import cv2
dem_new = cv2.resize(dem, (dem.shape[1]//2, dem.shape[0]//2), interpolation=cv2.INTER_AREA)

dem_new.shape

from PIL import Image, ImageEnhance
import numpy as np

# Если dem_example — NumPy-массив (например, float32 или int32)
if isinstance(dem_example, np.ndarray):
    # Нормализуем данные в диапазон 0-255
    normalized = (dem_example - np.min(dem_example)) / (np.max(dem_example) - np.min(dem_example)) * 255
    image_pil = Image.fromarray(normalized.astype('uint8'))  # Конвертируем в 8-битное
else:
    # Если это PIL-изображение, но в неправильном режиме (например, 'F')
    image_pil = dem_example.convert('L')  # Преобразуем в 8-битное grayscale

# Теперь можно применять контраст
enhancer = ImageEnhance.Contrast(image_pil)
contrasted = enhancer.enhance(2)  # Увеличиваем контраст в 2 раза

# Сохраняем
#contrasted.save('contrast_pil.jpg')

# Сохранение как TIFF-файл
driver = "GTiff"
dim = dem_example.shape
height = dim[0]
width = dim[1]
count = 1
dtype = dem_example.dtype
print(dtype)

from rasterio.crs import CRS
from rasterio.transform import from_origin

filename = "/content/ALOS_3D_30M_FULL_COVER.tif"
raster_file = rasterio.open(filename)
raster_array = raster_file.read()
transform  = raster_file.profile['transform']
crs = CRS.from_epsg(4326)
print(raster_array.shape)
print(transform)

with rasterio.open("ALOS_converted_8bit.tif", "w",driver= driver, height = height, width = width, count =1, dtype =dtype, crs = crs, transform = transform) as dst:
    dst.write(dem_example, 1)

contrasted_array = np.array(contrasted)  # Преобразуем в NumPy-массив

# Проверяем тип и форму
print("Тип массива:", contrasted_array.dtype)  # Ожидается uint8
print("Форма массива:", contrasted_array.shape)  # (height, width) или (height, width, channels)

def extract_lineaments(dem_path, output_path, sigma=1, threshold=0.1, min_length=1):
    """
    Алгоритм выделения линеаментов из ЦМР

    Параметры:
    dem_path - путь к файлу ЦМР (GeoTIFF)
    output_path - путь для сохранения результатов
    sigma - параметр размытия для гауссова фильтра
    threshold - порог для выделения границ
    min_length - минимальная длина линеамента (в пикселях)
    """

    # 1. Загрузка ЦМР
    dem = dem_path

    # 2. Предварительная обработка
    # Заполнение пропущенных значений (если есть)
    dem = np.where(dem == src.nodata, np.nanmean(dem), dem)

    # 3. Расчет производных (градиентов)
    sobel_x = ndimage.sobel(dem, axis=0, mode='constant')
    sobel_y = ndimage.sobel(dem, axis=1, mode='constant')

    # 4. Расчет азимутов и крутизны склонов
    aspect = np.arctan2(sobel_y, sobel_x)
    slope = np.sqrt(sobel_x**2 + sobel_y**2)

    # 5. Выделение линейных структур
    # Применение гауссова фильтра
    smoothed = filters.gaussian(slope, sigma=sigma)

    # Детектирование краев (можно использовать Canny или другие методы)
    edges = feature.canny(smoothed, sigma=sigma, low_threshold=threshold*0.1,
                         high_threshold=threshold)

    # 6. Утоньшение линий
    skeleton = morphology.skeletonize(edges)

    # 7. Удаление коротких линий
    cleaned = morphology.remove_small_objects(skeleton, min_size=min_length)

    # 8. Векторизация линеаментов
    labeled = measure.label(cleaned)
    lines = measure.regionprops(labeled)

    # 9. Визуализация результатов
    fig, (ax1) = plt.subplots(1, 1, figsize=(15, 15))

    ax1.imshow(dem, cmap='gray')
    ax1.imshow(cleaned, cmap='Reds', alpha=0.5)
    ax1.set_title('Выделенные линеаменты')

    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()

    # 10. Возвращаем результаты (можно также сохранить в векторный формат)
    return {
        'dem': dem,
        'slope': slope,
        'aspect': aspect,
        'lineaments': cleaned,
        'lines': lines
    }

if __name__ == "__main__":
    dem_file = dem_example
    output_image = 'lineaments_result_1.png'

    results = extract_lineaments(dem_file, output_image,
                               sigma=1, threshold=0.05, min_length=5)

    print(f"Обнаружено {len(results['lines'])} линеаментов")

"""#Наиболее валидные линеаменты"""

import numpy as np
import rasterio
from skimage import filters, feature, morphology, exposure, img_as_float
from scipy import ndimage
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap

def enhanced_preprocessing(dem, median_size=3, normalize_method='histogram'):
    """
    Расширенная предварительная обработка DEM данных
    :param dem: входной массив высот
    :param median_size: размер ядра медианного фильтра
    :param normalize_method: метод нормализации ('histogram', 'percentile', 'none')
    :return: обработанный массив высот
    """
    # Заполнение пропущенных значений
    dem = np.ma.masked_invalid(dem).filled(np.nanmean(dem))

    # Медианная фильтрация для удаления шумов
    if median_size > 0:
        dem = filters.median(dem, np.ones((median_size, median_size)))

    # Нормализация данных
    if normalize_method == 'histogram':
        dem = exposure.equalize_hist(dem)
    elif normalize_method == 'percentile':
        plow, phigh = np.percentile(dem, [2, 98])
        dem = exposure.rescale_intensity(dem, in_range=(plow, phigh))

    # Преобразование к float в диапазоне [0,1]
    dem = img_as_float(dem)

    return dem

def calculate_slope(dem, z_factor=1.0):
    """
    Расчет крутизны склонов с улучшенным подавлением шумов
    :param dem: массив высот
    :param z_factor: множитель для вертикальных единиц
    :return: массив крутизны склонов
    """
    # Вычисление градиентов с использованием фильтра Собеля
    kernel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) / 8
    kernel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]]) / 8

    grad_x = ndimage.sobel(dem, axis=0)
    grad_y = ndimage.sobel(dem, axis=1)

    # Расчет крутизны
    slope = np.arctan(z_factor * np.sqrt(grad_x**2 + grad_y**2))
    return slope

def detect_lineaments(dem_path, output_path,
                    median_size=3,
                    normalize_method='histogram',
                    sigma=1.5,
                    low_threshold=0.08,
                    high_threshold=0.16,
                    min_line_length=15,
                    line_thickness=1):
    """
    Основная функция для выделения линеаментов
    """
    try:
        #with rasterio.open(dem_path) as src:
        dem = part1
            #profile = src.profile

            # 1. Улучшенная предварительная обработка
        dem_processed = enhanced_preprocessing(dem,
                                                 median_size=median_size,
                                                 normalize_method=normalize_method)

            # 2. Расчет крутизны склонов
        slope = calculate_slope(dem_processed)

            # 3. Многомасштабное выделение границ
            # Первый проход - крупные структуры


        edges_large = feature.canny(slope,
                                      sigma=sigma*5
                                      )

            # Второй проход - мелкие структуры
        edges_small = feature.canny(slope,
                                      sigma=sigma*0.7
                                    )

            # Комбинирование результатов
        edges_combined = np.logical_or(edges_large, edges_small)

            # 4. Постобработка
            # Утоньшение линий
        skeleton = morphology.skeletonize(edges_combined)

            # Удаление мелких объектов
        cleaned = morphology.remove_small_objects(skeleton, min_size=min_line_length)

        # 8. Векторизация линеаментов
        labeled = measure.label(cleaned)
        lines = measure.regionprops(labeled)
            # Утолщение линий для визуализации
        #if line_thickness > 1:
            #cleaned = morphology.binary_dilation(cleaned, np.ones((line_thickness, line_thickness)))

            # 5. Визуализация результатов
        fig, (ax3) = plt.subplots(1, 1, figsize=(18, 6))

            # Исходные данные
        #ax1.imshow(dem, cmap='terrain')
        #ax1.set_title('Исходная ЦМР')

            # Обработанные данные и крутизна
        #ax2.imshow(slope, cmap='viridis')
        #ax2.set_title('Крутизна склонов')

            # Линеаменты
        #ax3.imshow(dem, cmap='terrain')
        ax3.imshow(cleaned, cmap='Reds', alpha=0.7)
        ax3.set_title('Выделенные линеаменты')

        plt.tight_layout()
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        plt.close()

            # 6. Сохранение результатов
            profile.update(dtype=rasterio.uint8, count=1, nodata=0)
            with rasterio.open(output_path.replace('.png', '.tif'), 'w', **profile) as dst:
                dst.write(cleaned.astype(rasterio.uint8), 1)

        return lines

    except Exception as e:
        print(f"Ошибка при обработке: {str(e)}")
        return None

# Пример использования
if __name__ == "__main__":
    # Параметры обработки
    params = {
        'dem_path': part1,
        'output_path': "lineaments_chukotka_ALOS_PART_1.png",
        'median_size': 10,               # Размер медианного фильтра
        'normalize_method': 'percentile', # Метод нормализации
        'sigma': 0.3,                   # Параметр для детектора Канни
        'low_threshold': 0,           # Нижний порог
        'high_threshold': 10,          # Верхний порог
        'min_line_length': 0,          # Минимальная длина линеамента
        'line_thickness': 2             # Толщина линий для визуализации
    }

    result = detect_lineaments(**params)
    print(result)
    if result is not None:
        print(f"Обработка завершена. Результаты сохранены в {params['output_path']}")
        print(f"Обнаружено {np.sum(result)} пикселей линеаментов")

import numpy as np
import rasterio
from skimage import filters, feature, morphology, exposure, img_as_float, measure
from scipy import ndimage
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import os

def enhanced_preprocessing(dem, median_size=3, normalize_method='histogram'):
    """
    Расширенная предварительная обработка DEM данных
    :param dem: входной массив высот
    :param median_size: размер ядра медианного фильтра
    :param normalize_method: метод нормализации ('histogram', 'percentile', 'none')
    :return: обработанный массив высот
    """
    # Заполнение пропущенных значений
    dem = np.ma.masked_invalid(dem).filled(np.nanmean(dem))

    # Медианная фильтрация для удаления шумов
    if median_size > 0:
        dem = filters.median(dem, np.ones((median_size, median_size)))

    # Нормализация данных
    if normalize_method == 'histogram':
        dem = exposure.equalize_hist(dem)
    elif normalize_method == 'percentile':
        plow, phigh = np.percentile(dem, [2, 98])
        dem = exposure.rescale_intensity(dem, in_range=(plow, phigh))

    # Преобразование к float в диапазоне [0,1]
    dem = img_as_float(dem)

    return dem

def calculate_slope(dem, z_factor=1.0):
    """
    Расчет крутизны склонов с улучшенным подавлением шумов
    :param dem: массив высот
    :param z_factor: множитель для вертикальных единиц
    :return: массив крутизны склонов
    """
    # Вычисление градиентов с использованием фильтра Собеля
    grad_x = ndimage.sobel(dem, axis=0)
    grad_y = ndimage.sobel(dem, axis=1)

    # Расчет крутизны
    slope = np.arctan(z_factor * np.sqrt(grad_x**2 + grad_y**2))
    return slope

def process_part(dem_part, profile, part_number, output_dir,
                median_size=10, normalize_method='histogram', sigma=0.3, min_line_length=0):
    """
    Обработка одной части DEM для выделения линеаментов
    """
    try:
        print(f"Обработка части {part_number}, размер: {dem_part.shape}")

        # 1. Улучшенная предварительная обработка
        dem_processed = enhanced_preprocessing(dem_part,
                                             median_size=median_size,
                                             normalize_method=normalize_method)

        # 2. Расчет крутизны склонов
        slope = calculate_slope(dem_processed)

        # 3. Многомасштабное выделение границ
        edges_large = feature.canny(slope, sigma=sigma*5)
        edges_small = feature.canny(slope, sigma=sigma*0.7)
        edges_combined = np.logical_or(edges_large, edges_small)

        # 4. Постобработка
        skeleton = morphology.skeletonize(edges_combined)
        cleaned = morphology.remove_small_objects(skeleton, min_size=min_line_length)

        # 5. Визуализация результатов
        fig, ax = plt.subplots(1, 1, figsize=(12, 10))
        ax.imshow(dem_part, cmap='terrain', alpha=0.7)
        ax.imshow(cleaned, cmap='Reds', alpha=0.5)
        ax.set_title(f'Линеаменты - часть {part_number}')
        ax.axis('off')

        output_png = os.path.join(output_dir, f'lineaments_part_{part_number}.png')
        plt.tight_layout()
        plt.savefig(output_png, dpi=300, bbox_inches='tight')
        plt.close()

        # 6. Сохранение растровых результатов в исходной системе координат
        output_profile = profile.copy()
        output_profile.update({
            'dtype': rasterio.uint8,
            'count': 1,
            'nodata': 0,
            'compress': 'lzw',
            'height': cleaned.shape[0],
            'width': cleaned.shape[1]
        })

        # Сохраняем бинарный растр линеаментов
        output_tif_path = os.path.join(output_dir, f'lineaments_part_{part_number}.tif')
        with rasterio.open(output_tif_path, 'w', **output_profile) as dst:
            dst.write(cleaned.astype(rasterio.uint8), 1)

        print(f"Растр линеаментов части {part_number} сохранен: {output_tif_path}")

        # 7. Векторизация линеаментов
        labeled = measure.label(cleaned)
        lines = measure.regionprops(labeled)

        return lines, cleaned, output_tif_path

    except Exception as e:
        print(f"Ошибка при обработке части {part_number}: {str(e)}")
        import traceback
        traceback.print_exc()
        return None, None, None

def split_and_process_dem(dem_path, output_dir, num_parts=3, **kwargs):
    """
    Разделяет DEM на части и обрабатывает каждую часть отдельно
    """
    try:
        # Создаем директорию для выходных файлов
        os.makedirs(output_dir, exist_ok=True)

        # Читаем исходный DEM
        with rasterio.open(dem_path) as src:
            dem = src.read(1)
            profile = src.profile
            crs = src.crs
            transform = src.transform

            print(f"Исходный DEM: {dem.shape}")
            print(f"Система координат: {crs}")
            print(f"Геопреобразование: {transform}")

        # Разделяем DEM на равные части по горизонтали
        height, width = dem.shape
        part_width = width // num_parts

        results = []

        for i in range(num_parts):
            # Определяем границы части
            start_col = i * part_width
            end_col = (i + 1) * part_width if i < num_parts - 1 else width

            # Вырезаем часть DEM
            dem_part = dem[:, start_col:end_col]

            # Обновляем геопреобразование для этой части
            part_transform = transform
            part_transform = rasterio.Affine(
                transform.a, transform.b, transform.c + start_col * transform.a,
                transform.d, transform.e, transform.f
            )

            part_profile = profile.copy()
            part_profile.update({
                'height': dem_part.shape[0],
                'width': dem_part.shape[1],
                'transform': part_transform
            })

            print(f"Часть {i+1}: колонки {start_col}-{end_col}, размер: {dem_part.shape}")

            # Обрабатываем часть
            result = process_part(
                dem_part=dem_part,
                profile=part_profile,
                part_number=i+1,
                output_dir=output_dir,
                **kwargs
            )

            results.append(result)

        return results

    except Exception as e:
        print(f"Ошибка при разделении и обработке DEM: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def detect_lineaments(dem_path, output_dir,
                    median_size=10,
                    normalize_method='histogram',
                    sigma=0.3,
                    low_threshold=0,
                    high_threshold=10,
                    min_line_length=0,
                    line_thickness=1):
    """
    Основная функция для выделения линеаментов с разделением на части
    """
    try:
        # Разделяем и обрабатываем DEM
        results = split_and_process_dem(
            dem_path=dem_path,
            output_dir=output_dir,
            num_parts=3,
            median_size=median_size,
            normalize_method=normalize_method,
            sigma=sigma,
            min_line_length=min_line_length
        )

        if results:
            total_lines = 0
            for i, (lines, _, _) in enumerate(results):
                if lines is not None:
                    print(f"Часть {i+1}: обнаружено {len(lines)} линеаментов")
                    total_lines += len(lines)

            print(f"Всего обнаружено линеаментов: {total_lines}")

            # Создаем объединенный визуальный отчет
            create_summary_plot(output_dir, dem_path)

        return results

    except Exception as e:
        print(f"Ошибка при обработке: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def create_summary_plot(output_dir, dem_path):
    """
    Создает сводный график со всеми частями
    """
    try:
        # Читаем исходный DEM для фона
        with rasterio.open(dem_path) as src:
            dem = src.read(1)

        fig, axes = plt.subplots(2, 2, figsize=(15, 12))

        # Отображаем исходный DEM
        axes[0, 0].imshow(dem, cmap='terrain')
        axes[0, 0].set_title('Исходный DEM')
        axes[0, 0].axis('off')

        # Загружаем и отображаем результаты для каждой части
        for i in range(3):
            tif_path = os.path.join(output_dir, f'lineaments_part_{i+1}.tif')
            if os.path.exists(tif_path):
                with rasterio.open(tif_path) as src:
                    lineaments = src.read(1)

                row = (i + 1) // 2
                col = (i + 1) % 2
                axes[row, col].imshow(dem, cmap='terrain', alpha=0.7)
                axes[row, col].imshow(lineaments, cmap='Reds', alpha=0.5)
                axes[row, col].set_title(f'Линеаменты - часть {i+1}')
                axes[row, col].axis('off')

        plt.tight_layout()
        summary_path = os.path.join(output_dir, 'summary_plot.png')
        plt.savefig(summary_path, dpi=300, bbox_inches='tight')
        plt.close()

        print(f"Сводный график сохранен: {summary_path}")

    except Exception as e:
        print(f"Ошибка при создании сводного графика: {str(e)}")

# Пример использования функции
if __name__ == "__main__":
    # Параметры обработки
    dem_path = "/content/CHUKOTKA_DEM_ALOS.tif"
    output_dir = "CHUKOTKA_DEM_ALOS"

    # Вызов основной функции
    results = detect_lineaments(
        dem_path=dem_path,
        output_dir=output_dir,
        median_size=10,
        normalize_method='histogram',
        sigma=0.3,
        min_line_length=0
    )

    if results:
        print("Обработка завершена успешно!")
        print(f"Результаты сохранены в директории: {output_dir}")

import numpy as np
import rasterio
from skimage import filters, feature, morphology, exposure, img_as_float, measure
from scipy import ndimage
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap

def enhanced_preprocessing(dem, median_size=3, normalize_method='histogram'):
    """
    Расширенная предварительная обработка DEM данных
    :param dem: входной массив высот
    :param median_size: размер ядра медианного фильтра
    :param normalize_method: метод нормализации ('histogram', 'percentile', 'none')
    :return: обработанный массив высот
    """
    # Заполнение пропущенных значений
    dem = np.ma.masked_invalid(dem).filled(np.nanmean(dem))

    # Медианная фильтрация для удаления шумов
    if median_size > 0:
        dem = filters.median(dem, np.ones((median_size, median_size)))

    # Нормализация данных
    if normalize_method == 'histogram':
        dem = exposure.equalize_hist(dem)
    elif normalize_method == 'percentile':
        plow, phigh = np.percentile(dem, [2, 98])
        dem = exposure.rescale_intensity(dem, in_range=(plow, phigh))

    # Преобразование к float в диапазоне [0,1]
    dem = img_as_float(dem)

    return dem

def calculate_slope(dem, z_factor=1.0):
    """
    Расчет крутизны склонов с улучшенным подавлением шумов
    :param dem: массив высот
    :param z_factor: множитель для вертикальных единиц
    :return: массив крутизны склонов
    """
    # Вычисление градиентов с использованием фильтра Собеля
    kernel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) / 8
    kernel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]]) / 8

    grad_x = ndimage.sobel(dem, axis=0)
    grad_y = ndimage.sobel(dem, axis=1)

    # Расчет крутизны
    slope = np.arctan(z_factor * np.sqrt(grad_x**2 + grad_y**2))
    return slope

def detect_lineaments(dem_path, output_path,
                    median_size=10,
                    normalize_method='histogram',
                    sigma=0.3,
                    low_threshold=0,
                    high_threshold=10,
                    min_line_length=0,
                    line_thickness=1):
    """
    Основная функция для выделения линеаментов
    """
    try:
        # Получаем данные из глобальной переменной part1
        dem = band1

        # Открываем исходный растр для получения метаданных
        with rasterio.open(dem_path) as src:
            profile = src.profile
            crs = src.crs
            transform = src.transform

        # 1. Улучшенная предварительная обработка
        dem_processed = enhanced_preprocessing(dem,
                                             median_size=median_size,
                                             normalize_method=normalize_method)

        # 2. Расчет крутизны склонов
        slope = calculate_slope(dem_processed)

        # 3. Многомасштабное выделение границ
        # Первый проход - крупные структуры
        edges_large = feature.canny(slope, sigma=sigma*5)

        # Второй проход - мелкие структуры
        edges_small = feature.canny(slope, sigma=sigma*0.7)

        # Комбинирование результатов
        edges_combined = np.logical_or(edges_large, edges_small)

        # 4. Постобработка
        # Утоньшение линий
        skeleton = morphology.skeletonize(edges_combined)

        # Удаление мелких объектов
        cleaned = morphology.remove_small_objects(skeleton, min_size=min_line_length)

        # 5. Визуализация результатов
        fig, ax = plt.subplots(1, 1, figsize=(12, 10))

        # Отображение линеаментов на фоне рельефа
        ax.imshow(dem, cmap='terrain', alpha=0.7)
        ax.imshow(cleaned, cmap='Reds', alpha=0.5)
        ax.set_title('Выделенные линеаменты')
        ax.axis('off')

        plt.tight_layout()
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        plt.close()

        # 6. Сохранение растровых результатов в исходной системе координат
        # Подготавливаем метаданные для выходного растра
        output_profile = profile.copy()
        output_profile.update({
            'dtype': rasterio.uint8,
            'count': 1,
            'nodata': 0,
            'compress': 'lzw'
        })

        # Сохраняем бинарный растр линеаментов
        output_tif_path = output_path.replace('.png', '_lineaments.tif')
        with rasterio.open(output_tif_path, 'w', **output_profile) as dst:
            dst.write(cleaned.astype(rasterio.uint8), 1)

        print(f"Растр линеаментов сохранен: {output_tif_path}")
        print(f"Система координат: {crs}")
        print(f"Геопреобразование: {transform}")

        # 7. Векторизация линеаментов
        labeled = measure.label(cleaned)
        lines = measure.regionprops(labeled)

        # 8. Дополнительно: сохраняем растр с исходными значениями для отладки
        output_slope_path = output_path.replace('.png', '_slope.tif')
        slope_profile = profile.copy()
        slope_profile.update({
            'dtype': rasterio.float32,
            'nodata': -9999
        })

        with rasterio.open(output_slope_path, 'w', **slope_profile) as dst:
            dst.write(slope.astype(rasterio.float32), 1)

        return lines, cleaned, output_tif_path

    except Exception as e:
        print(f"Ошибка при обработке: {str(e)}")
        import traceback
        traceback.print_exc()
        return None, None, None

# Пример использования функции
if __name__ == "__main__":
    # Замените на ваш путь к DEM
    dem_path = "/content/Sentinel_B6_AOI_Chukotka.tif"
    output_path = "Chukotka_SENTINEL.png"


    # Вызов функции
    lines, lineament_raster, output_tif = detect_lineaments(
        dem_path=dem_path,
        output_path=output_path,
        median_size=10,
        normalize_method='histogram',
        sigma=0.3,
        min_line_length=0
    )

    if lines is not None:
        print(f"Обнаружено {len(lines)} линеаментов")
        print(f"Растр сохранен в: {output_tif}")

"""# Плотность линеаментов"""

def calculate_lineament_density(input_raster, output_raster, window_size=500, resolution=30):
    """
    Рассчитывает плотность линеаментов с помощью скользящего окна

    Parameters:
    input_raster: путь к входному растру линеаментов
    output_raster: путь для сохранения растра плотности
    window_size: размер скользящего окна в пикселях
    resolution: пространственное разрешение растра (метры на пиксель)
    """

    try:
        # Открываем входной растр
        with rasterio.open(input_raster) as src:
            # Читаем данные
            data = src.read(1)
            profile = src.profile.copy()

            # Получаем геопривязку
            transform = src.transform
            crs = src.crs

            print(f"Размер растра: {data.shape}")
            print(f"Разрешение: {resolution} м/пиксель")
            print(f"CRS: {crs}")

        # Создаем бинарную маску (1 - линеамент, 0 - фон)
        binary_data = np.where(data > 0, 1, 0)

        # Создаем ядро для скользящего окна
        kernel = np.ones((window_size, window_size), dtype=np.float32)

        # Вычисляем плотность с помощью свертки
        density = ndimage.convolve(binary_data.astype(np.float32),
                                 kernel,
                                 mode='constant',
                                 cval=0.0)

        # Нормализуем плотность (количество пикселей линеаментов на площадь окна)
        window_area = window_size * window_size
        density = density / window_area

        # Масштабируем для лучшего отображения (опционально)
        density = density * 10000  # плотность на 10000 пикселей

        # Обновляем метаданные для выходного файла
        profile.update(
            dtype=rasterio.float32,
            count=1,
            compress='lzw',
            nodata=-9999
        )

        # Сохраняем результат
        with rasterio.open(output_raster, 'w', **profile) as dst:
            dst.write(density.astype(np.float32), 1)

            # Устанавливаем метаданные
            dst.update_tags(
                Title='Lineament Density',
                Units='Density per 10000 pixels',
                Window_Size=f'{window_size} pixels',
                Resolution=f'{resolution} meters'
            )

        print(f"Плотность линеаментов успешно рассчитана!")
        print(f"Результат сохранен в: {output_raster}")
        print(f"Диапазон значений плотности: {density.min():.4f} - {density.max():.4f}")

        return density

    except Exception as e:
        print(f"Ошибка: {e}")
        return None

# ПРИМЕНЕНИЕ ПЛОТНОСТИ

density = calculate_lineament_density('/content/Chukotka_LANDSAT_lineaments.tif', 'Chukotka_LANDSAT_lineaments_DENSITY')

import numpy as np
import rasterio
from skimage import measure, morphology
from shapely.geometry import LineString, MultiLineString
import geopandas as gpd
import math
from shapely.ops import linemerge, unary_union
from shapely.geometry import GeometryCollection

def save_lineaments_to_shapefile(lines, raster_path, output_shapefile):
    """
    Сохраняет линеаменты в шейп-файл с привязкой к координатам растра

    :param lines: список объектов RegionProperties из skimage.measure
    :param raster_path: путь к исходному растру DEM
    :param output_shapefile: путь для сохранения шейп-файла
    """
    # Открываем растр для получения трансформации и CRS
    with rasterio.open(raster_path) as src:
        transform = src.transform
        crs = src.crs

    # Собираем все линии в список
    line_features = []

    for line in lines:
        # Получаем координаты пикселей линии
        coords = line.coords

        # Проверяем, что линия содержит хотя бы 2 точки
        if len(coords) < 2:
            continue

        # Преобразуем пиксельные координаты в географические
        world_coords = []
        for y, x in coords:
            # Преобразуем координаты пикселей в географические
            geo_x, geo_y = transform * (x, y)
            world_coords.append((geo_x, geo_y))

        # Создаем LineString объект только если есть хотя бы 2 точки
        if len(world_coords) >= 2:
            try:
                line_string = LineString(world_coords)
                # Проверяем, что линия валидна и не пустая
                if line_string.is_valid and not line_string.is_empty:
                    line_features.append(line_string)
            except Exception as e:
                print(f"Ошибка при создании LineString: {e}")
                continue

    # Функция для вычисления угла между двумя точками
    def angle_between(p1, p2):
        return math.atan2(p2[1]-p1[1], p2[0]-p1[0]) * 180 / math.pi

    # 2. Объединение близких параллельных линий (только если есть линии)
    final_lines = []

    if line_features:
        try:
            # Создаем объединенную геометрию
            union_geom = unary_union(line_features)

            # Пытаемся объединить линии
            merged_geometry = union_geom

            # Извлекаем линии из результата
            if isinstance(merged_geometry, GeometryCollection):
                merged_lines = [geom for geom in merged_geometry.geoms
                              if isinstance(geom, LineString) and len(geom.coords) >= 2]
            elif isinstance(merged_geometry, LineString):
                if len(merged_geometry.coords) >= 2:
                    merged_lines = [merged_geometry]
                else:
                    merged_lines = []
            elif isinstance(merged_geometry, MultiLineString):
                merged_lines = [geom for geom in merged_geometry.geoms
                              if len(geom.coords) >= 2]
            else:
                merged_lines = []

        except Exception as e:
            print(f"Ошибка при объединении линий: {e}")
            merged_lines = line_features  # Используем исходные линии если объединение не удалось
    else:
        merged_lines = []

    # 3. Фильтрация по ориентации
    for line in merged_lines:
        try:
            coords = list(line.coords)
            if len(coords) >= 2:
                angle = angle_between(coords[0], coords[-1])
                # Игнорируем почти горизонтальные линии (±5 градусов)
                if not (-5 < angle < 5):
                    final_lines.append(line)
        except Exception as e:
            print(f"Ошибка при фильтрации линии: {e}")
            continue

    # Создаем GeoDataFrame
    if final_lines:
        gdf = gpd.GeoDataFrame(geometry=final_lines, crs=crs)

        # Добавляем атрибуты для каждой линии
        gdf['length'] = gdf.geometry.length  # Длина линии в метрах
        gdf['id'] = range(1, len(gdf) + 1)   # Уникальный идентификатор

        # Добавляем информацию об ориентации
        orientations = []
        for geom in gdf.geometry:
            coords = list(geom.coords)
            if len(coords) >= 2:
                angle = angle_between(coords[0], coords[-1])
                orientations.append(angle)
            else:
                orientations.append(0)

        gdf['orientation'] = orientations

        # Сохраняем в шейп-файл
        gdf.to_file(output_shapefile, encoding='utf-8')
        print(f"Линеаменты успешно сохранены в {output_shapefile}")
        print(f"Сохранено {len(final_lines)} линеаментов")

        # Выводим статистику
        print(f"Общее количество линий: {len(final_lines)}")
        print(f"Средняя длина: {gdf['length'].mean():.2f} м")
        print(f"Максимальная длина: {gdf['length'].max():.2f} м")

    else:
        print("Нет линеаментов для сохранения")
        # Создаем пустой GeoDataFrame для сохранения структуры
        gdf = gpd.GeoDataFrame(geometry=[], crs=crs)
        gdf.to_file(output_shapefile, encoding='utf-8')

# Пример вызова функции
# save_lineaments_to_shapefile(result, '/content/CHUKOTKA_DEM_ALOS.tif', 'output_lineaments.shp')

def save_lineaments_to_shapefile(lines, raster_path, output_shapefile):
    """
    Сохраняет линеаменты в шейп-файл с привязкой к координатам растра

    :param lines: список объектов RegionProperties из skimage.measure
    :param raster_path: путь к исходному растру DEM
    :param output_shapefile: путь для сохранения шейп-файла
    """
    # Открываем растр для получения трансформации и CRS
    with rasterio.open(raster_path) as src:
        transform = src.transform
        crs = src.crs

    # Собираем все линии в список
    line_features = []

    for line in lines:
        # Получаем координаты пикселей линии
        coords = line.coords

        # Проверяем, что линия содержит хотя бы 2 точки
        if len(coords) < 2:
            continue

        # Преобразуем пиксельные координаты в географические
        world_coords = []
        for y, x in coords:
            # Преобразуем координаты пикселей в географические
            geo_x, geo_y = transform * (x, y)
            world_coords.append((geo_x, geo_y))

        # Создаем LineString объект только если есть хотя бы 2 точки
        if len(world_coords) >= 2:
            try:
                line_string = LineString(world_coords)
                # Проверяем, что линия валидна и не пустая
                if line_string.is_valid and not line_string.is_empty:
                    line_features.append(line_string)
            except Exception as e:
                print(f"Ошибка при создании LineString: {e}")
                continue

    # Функция для вычисления угла между двумя точками
    def angle_between(p1, p2):
        return math.atan2(p2[1]-p1[1], p2[0]-p1[0]) * 180 / math.pi

    # 2. Объединение близких параллельных линий (только если есть линии)
    final_lines = []

    if line_features:
        try:
            # Создаем объединенную геометрию
            union_geom = unary_union(line_features)

            # Пытаемся объединить линии
            merged_geometry = union_geom

            # Извлекаем линии из результата
            if isinstance(merged_geometry, GeometryCollection):
                merged_lines = [geom for geom in merged_geometry.geoms
                              if isinstance(geom, LineString) and len(geom.coords) >= 2]
            elif isinstance(merged_geometry, LineString):
                if len(merged_geometry.coords) >= 2:
                    merged_lines = [merged_geometry]
                else:
                    merged_lines = []
            elif isinstance(merged_geometry, MultiLineString):
                merged_lines = [geom for geom in merged_geometry.geoms
                              if len(geom.coords) >= 2]
            else:
                merged_lines = []

        except Exception as e:
            print(f"Ошибка при объединении линий: {e}")
            merged_lines = line_features  # Используем исходные линии если объединение не удалось
    else:
        merged_lines = []

    # 3. Фильтрация по ориентации
    for line in merged_lines:
        try:
            coords = list(line.coords)
            if len(coords) >= 2:
                angle = angle_between(coords[0], coords[-1])
                # Игнорируем почти горизонтальные линии (±5 градусов)
                if not (-5 < angle < 5):
                    final_lines.append(line)
        except Exception as e:
            print(f"Ошибка при фильтрации линии: {e}")
            continue

    # Создаем GeoDataFrame
    if final_lines:
        gdf = gpd.GeoDataFrame(geometry=final_lines, crs=crs)

        # Добавляем атрибуты для каждой линии
        gdf['length'] = gdf.geometry.length  # Длина линии в метрах
        gdf['id'] = range(1, len(gdf) + 1)   # Уникальный идентификатор

        # Добавляем информацию об ориентации
        orientations = []
        for geom in gdf.geometry:
            coords = list(geom.coords)
            if len(coords) >= 2:
                angle = angle_between(coords[0], coords[-1])
                orientations.append(angle)
            else:
                orientations.append(0)

        gdf['orientation'] = orientations

        # Сохраняем в шейп-файл
        gdf.to_file(output_shapefile, encoding='utf-8')
        print(f"Линеаменты успешно сохранены в {output_shapefile}")
        print(f"Сохранено {len(final_lines)} линеаментов")

        # Выводим статистику
        print(f"Общее количество линий: {len(final_lines)}")
        print(f"Средняя длина: {gdf['length'].mean():.2f} м")
        print(f"Максимальная длина: {gdf['length'].max():.2f} м")

    else:
        print("Нет линеаментов для сохранения")
        # Создаем пустой GeoDataFrame для сохранения структуры
        gdf = gpd.GeoDataFrame(geometry=[], crs=crs)
        gdf.to_file(output_shapefile, encoding='utf-8')

save_lineaments_to_shapefile(result, '/content/CHUKOTKA_DEM_ALOS.tif', 'output_lineaments114.shp')

driver = "GTiff"
dim = dem_example.shape
height = dim[0]
width = dim[1]
count = 1
dtype =dem_example.dtype
print(dtype)

import numpy as np
import rasterio
from skimage import filters, feature, morphology, exposure, img_as_float, measure
from scipy import ndimage
import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import LineString
import pandas as pd
from shapely.ops import linemerge, smooth

def enhanced_preprocessing(dem, median_size=3, normalize_method='histogram'):
    """Расширенная предварительная обработка DEM данных."""
    dem = np.ma.masked_invalid(dem).filled(np.nanmean(dem))
    if median_size > 0:
        dem = filters.median(dem, np.ones((median_size, median_size)))
    if normalize_method == 'histogram':
        dem = exposure.equalize_hist(dem)
    elif normalize_method == 'percentile':
        plow, phigh = np.percentile(dem, [2, 98])
        dem = exposure.rescale_intensity(dem, in_range=(plow, phigh))
    return img_as_float(dem)

def calculate_slope(dem, z_factor=1.0):
    """Расчет крутизны склонов."""
    grad_x = ndimage.sobel(dem, axis=0)
    grad_y = ndimage.sobel(dem, axis=1)
    return np.arctan(z_factor * np.sqrt(grad_x**2 + grad_y**2))

def detect_lineaments(dem_path, output_shp, output_png,
                    median_size=3, normalize_method='histogram',
                    sigma=0.5, min_line_length=20, min_eccentricity=0.7):
    """
    Основная функция для выделения и сохранения линеаментов.

    :param dem_path: путь к файлу DEM (или массив numpy)
    :param output_shp: путь для сохранения шэйп-файла
    :param output_png: путь для сохранения визуализации
    :return: GeoDataFrame с линеаментами
    """
    try:
        # Загрузка данных (если dem_path - это путь)
        if isinstance(dem_path, str):
            with rasterio.open(dem_path) as src:
                dem = src.read(1)
                transform = src.transform
                crs = src.crs
        else:
            dem = dem_path
            transform = None  # Если transform неизвестен
            crs = "EPSG:4326"  # Предполагаем WGS-84

        # Предобработка и выделение линеаментов
        dem_processed = enhanced_preprocessing(dem, median_size, normalize_method)
        slope = calculate_slope(dem_processed)
        edges_large = feature.canny(slope, sigma=sigma*5)
        edges_small = feature.canny(slope, sigma=sigma*0.7)
        edges_combined = np.logical_or(edges_large, edges_small)
        skeleton = morphology.skeletonize(edges_combined)
        cleaned = morphology.remove_small_objects(skeleton, min_size=min_line_length)

        # Векторизация линий
        lines = measure.label(cleaned)
        regions = measure.regionprops(lines)

        # Создание GeoDataFrame
        line_features = []
        for region in regions:
            # Фильтрация по длине и форме
            if len(region.coords) >= min_line_length and region.eccentricity >= min_eccentricity:
                coords = region.coords

                # Преобразование координат
                if transform:
                    # Правильный порядок: (cols, rows) -> (x, y)
                    xs, ys = transform * (coords[:, 1], coords[:, 0])
                    line = LineString(zip(xs, ys))
                else:
                    line = LineString(coords[:, [1, 0]])  # (col, row) -> (x, y)

                line_features.append(line)

        # Создание GeoDataFrame
        gdf = gpd.GeoDataFrame(geometry=line_features, crs=crs)

        # Визуализация
        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6))
        ax1.imshow(dem, cmap='terrain')
        ax1.set_title('Исходная ЦМР')
        ax2.imshow(slope, cmap='viridis')
        ax2.set_title('Крутизна склонов')
        ax3.imshow(dem, cmap='terrain')
        ax3.imshow(cleaned, cmap='Reds', alpha=0.7)
        ax3.set_title('Выделенные линеаменты')
        plt.tight_layout()
        plt.savefig(output_png, dpi=300, bbox_inches='tight')
        plt.close()

        return gdf

    except Exception as e:
        print(f"Ошибка: {e}")
        return None

def postprocess_lines(gdf, tolerance=2.0):
    """Постобработка линий: упрощение и сглаживание"""
    simplified_lines = []
    for line in gdf.geometry:
        # Упрощение
        simple_line = simplify(line, tolerance=tolerance)
        # Сглаживание (если нужно)
        if simple_line.length > tolerance*2:
            smooth_line = smooth(simple_line, resolution=3)
            simplified_lines.append(smooth_line)
        else:
            simplified_lines.append(simple_line)

    gdf_1 = gpd.GeoDataFrame(geometry=simplified_lines, crs=gdf.crs)
    return gdf_1

    if not gdf_1.empty:
        gdf_1.to_crs("EPSG:4326").to_file(output_shp)  # Явное преобразование в WGS-84
    else:
        print("Линеаменты не обнаружены.")

# Пример использования
if __name__ == "__main__":
    #dem_example = contrasted_array  # Тестовые данные (замените на реальный DEM)
    gdf = detect_lineaments(
        part1,
        output_shp="lineaments_1.shp",
        output_png="lineaments_1.png"
    )

gdf

gdf_smooth = postprocess_lines(gdf, tolerance=5.0)
gdf_smooth.to_file(output_shp)

"""# САМЫЕ ВАЛИДНЫЕ ЛИНЕАМЕНТЫ

"""

import numpy as np
import rasterio
from rasterio.plot import show
from skimage import filters, feature, morphology, measure
from skimage.exposure import equalize_hist
import geopandas as gpd
from shapely.geometry import LineString
from shapely.ops import linemerge
import matplotlib.pyplot as plt
from typing import Tuple, Dict, Optional
from rasterio.transform import Affine

class LineamentDetector:
    def __init__(self, min_length_pixels: int = 300,
                 canny_sigma: float = 0.8,
                 simplify_tolerance: float = 2.0):
        """
        Полнофункциональный детектор линеаментов

        Параметры:
        min_length_pixels - минимальная длина в пикселях
        canny_sigma - параметр размытия для детектора границ
        simplify_tolerance - степень упрощения линий
        """
        self.min_length = min_length_pixels
        self.canny_sigma = canny_sigma
        self.simplify_tol = simplify_tolerance
        self.transform = None
        self.crs = None

    def _preprocess_dem(self, dem: np.ndarray) -> np.ndarray:
        """Предварительная обработка ЦМР"""
        try:
            # Нормализация гистограммы
            dem_norm = equalize_hist(dem)
            # Медианная фильтрация
            dem_filtered = filters.median(dem_norm, morphology.disk(3))
            # Гауссово размытие
            return filters.gaussian(dem_filtered, sigma=1.0)
        except Exception as e:
            print(f"Ошибка предобработки: {e}")
            return dem

    def _detect_edges(self, dem: np.ndarray) -> np.ndarray:
        """Детектирование границ с улучшенным алгоритмом"""
        try:
            # Расчет градиентов
            dy, dx = np.gradient(dem)
            gradient_mag = np.sqrt(dx**2 + dy**2)

            # Адаптивный детектор Canny
            p_low = np.percentile(gradient_mag, 25)
            p_high = np.percentile(gradient_mag, 75)

            edges = feature.canny(
                gradient_mag,
                sigma=self.canny_sigma,
                low_threshold=p_low,
                high_threshold=p_high
            )

            # Улучшение связности линий
            return morphology.binary_closing(edges, morphology.disk(2))
        except Exception as e:
            print(f"Ошибка детектирования границ: {e}")
            return np.zeros_like(dem, dtype=bool)

    def _vectorize_edges(self, edges: np.ndarray) -> gpd.GeoDataFrame:
        try:
            from skimage.transform import probabilistic_hough_line

    # Параметры для детекции прямых
            hough_params = {
            'threshold': 50,
            'line_length': self.min_length,
            'line_gap': 5,
            'theta': np.linspace(-np.pi/2, np.pi/2, 180)  # Шаг 1 градус
            }

    # Детекция прямых линий методом Хафа
            lines = probabilistic_hough_line(edges, **hough_params)

            features = []
            for line in lines:
                p0, p1 = line
                if self.transform:
            # Преобразование координат
                    x0, y0 = self.transform * (p0[0], p0[1])
                    x1, y1 = self.transform * (p1[0], p1[1])
                    line_geom = LineString([(x0, y0), (x1, y1)])
                else:
                    line_geom = LineString([(p0[0], p0[1]), (p1[0], p1[1])])

        # Фильтр по минимальной длине
                if line_geom.length >= self.min_length:
                    features.append(line_geom)

            return gpd.GeoDataFrame(geometry=features, crs=self.crs)

        except Exception as e:
            print(f"Ошибка векторизации: {e}")
            return gpd.GeoDataFrame(geometry=[], crs=self.crs)

    def _postprocess_lines(self, gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:

        if not isinstance(gdf, gpd.GeoDataFrame) or gdf.empty:
            return gpd.GeoDataFrame(geometry=[], crs=self.crs)

        try:
        # Объединение линий с преобразованием MultiLineString в список LineString
            merged = linemerge(gdf.geometry.tolist())  # Преобразуем в список геометрий

            processed = []

        # Обработка как единой линии или набора линий
            if merged.geom_type == 'MultiLineString':
                for line in merged.geoms:  # Используем .geoms для MultiLineString
                    try:
                        simplified = line.simplify(self.simplify_tol)
                        if not simplified.is_empty:
                            min_length = self.min_length * abs(self.transform.a) if self.transform else self.min_length
                            if simplified.length >= min_length:
                                processed.append(simplified)
                    except Exception as e:
                        print(f"Ошибка упрощения линии: {e}")
                        continue
            elif merged.geom_type == 'LineString':
                try:
                    simplified = merged.simplify(self.simplify_tol)
                    if not simplified.is_empty:
                        min_length = self.min_length * abs(self.transform.a) if self.transform else self.min_length
                        if simplified.length >= min_length:
                            processed.append(simplified)
                except Exception as e:
                    print(f"Ошибка упрощения линии: {e}")
            else:
                print(f"Неожиданный тип геометрии: {merged.geom_type}")

            return gpd.GeoDataFrame(geometry=processed, crs=self.crs)

        except Exception as e:
            print(f"Ошибка постобработки: {e}")
            return gpd.GeoDataFrame(geometry=[], crs=self.crs)

    def _calculate_stats(self, gdf: gpd.GeoDataFrame) -> Dict:
        """Расчет статистики"""
        if not isinstance(gdf, gpd.GeoDataFrame) or gdf.empty:
            return {
                'total_count': 0,
                'total_length': 0.0,
                'avg_length': 0.0,
                'max_length': 0.0,
                'orientation_bins': (np.array([]), np.array([]))
            }

        try:
            lengths = []
            orientations = []

            for geom in gdf.geometry:
                if not geom.is_empty:
                    lengths.append(geom.length)
                    coords = np.array(geom.coords)
                    if len(coords) >= 2:
                        dx = coords[-1,0] - coords[0,0]
                        dy = coords[-1,1] - coords[0,1]
                        angle = np.degrees(np.arctan2(dy, dx)) % 180
                        orientations.append(angle)

            if not lengths:
                return {
                    'total_count': 0,
                    'total_length': 0.0,
                    'avg_length': 0.0,
                    'max_length': 0.0,
                    'orientation_bins': (np.array([]), np.array([]))
                }

            return {
                'total_count': len(lengths),
                'total_length': float(np.sum(lengths)),
                'avg_length': float(np.mean(lengths)),
                'max_length': float(np.max(lengths)),
                'orientation_bins': np.histogram(orientations, bins=np.linspace(0, 180, 13)) if orientations else (np.array([]), np.array([]))
            }

        except Exception as e:
            print(f"Ошибка расчета статистики: {e}")
            return {
                'total_count': 0,
                'total_length': 0.0,
                'avg_length': 0.0,
                'max_length': 0.0,
                'orientation_bins': (np.array([]), np.array([]))
            }

    def process(self, input_raster: str,
               output_shp: str,
               output_png: str) -> Tuple[Optional[gpd.GeoDataFrame], Dict]:
        """
        Основной метод обработки

        Параметры:
        input_raster - путь к входному растру
        output_shp - путь для сохранения шейп-файла
        output_png - путь для сохранения визуализации

        Возвращает:
        Кортеж (GeoDataFrame с линеаментами, статистика)
        """
        try:
            # Загрузка данных
            dem = dem

            # Обработка данных
            processed_dem = self._preprocess_dem(dem)
            edges = self._detect_edges(processed_dem)
            raw_lines = self._vectorize_edges(edges)
            final_lines = self._postprocess_lines(raw_lines)
            stats = self._calculate_stats(final_lines)

            # Сохранение результатов
            if not final_lines.empty:
                try:
                    final_lines.to_file(output_shp)
                except Exception as e:
                    print(f"Ошибка сохранения шейп-файла: {e}")

            # Визуализация
            try:
                fig, ax = plt.subplots(figsize=(12, 12))
                show(dem, ax=ax, cmap='terrain')

                if not final_lines.empty:
                    final_lines.plot(ax=ax, color='red', linewidth=1.5)

                ax.set_title(f"Линеаменты (N={stats['total_count']}, L={stats['total_length']:.1f} м)")
                plt.savefig(output_png, dpi=300, bbox_inches='tight')
                plt.close()
            except Exception as e:
                print(f"Ошибка визуализации: {e}")
                plt.close('all')

            return final_lines, stats

        except Exception as e:
            print(f"Критическая ошибка обработки: {e}")
            return None, {
                'total_count': 0,
                'total_length': 0.0,
                'avg_length': 0.0,
                'max_length': 0.0,
                'orientation_bins': (np.array([]), np.array([]))
            }

if __name__ == "__main__":
    detector = LineamentDetector(min_length_pixels=100)
    lines, stats = detector.process(
        input_raster=dem,
        output_shp="output_lineaments_CHUKOTKA.shp",
        output_png="lineaments_CHUKOTKA.png"
    )

    if lines is not None:
        print("\nСтатистика линеаментов:")
        print(f"Всего линий: {stats['total_count']}")
        print(f"Суммарная длина: {stats['total_length']:.2f} м")
        print(f"Средняя длина: {stats['avg_length']:.2f} м")

"""#Дальше просто примеры"""

import numpy as np
import matplotlib.pyplot as plt
from skimage import exposure, filters, feature, morphology, transform
from skimage.morphology import disk
import geopandas as gpd
from shapely.geometry import LineString, MultiLineString
from shapely.ops import linemerge
from typing import Dict, Tuple, Optional
import rasterio
from rasterio.plot import show
import warnings
warnings.filterwarnings('ignore')

class LineamentDetector:
    def __init__(self, min_length_pixels: int = 300,
                 canny_sigma: float = 0.8,
                 simplify_tolerance: float = 2.0):
        """
        Полнофункциональный детектор линеаментов

        Параметры:
        min_length_pixels - минимальная длина в пикселях
        canny_sigma - параметр размытия для детектора границ
        simplify_tolerance - степень упрощения линий
        """
        self.min_length = min_length_pixels
        self.canny_sigma = canny_sigma
        self.simplify_tol = simplify_tolerance
        self.transform = None
        self.crs = None

    def _preprocess_dem(self, dem: np.ndarray) -> np.ndarray:
        """Предварительная обработка ЦМР: нормализация, фильтрация, сглаживание."""
        try:
            # Нормализация гистограммы для увеличения контраста
            dem_norm = exposure.equalize_hist(dem)
            # Медианная фильтрация для подавления шума
            dem_filtered = filters.median(dem_norm, disk(3))
            # Гауссово размытие для сглаживания
            return filters.gaussian(dem_filtered, sigma=1.0)
        except Exception as e:
            print(f"Ошибка предобработки: {e}")
            return dem

    def _detect_edges(self, dem: np.ndarray) -> np.ndarray:
        """Детектирование границ с улучшенным алгоритмом на основе Canny."""
        try:
            # Расчет градиентов (производных по X и Y)
            dy, dx = np.gradient(dem)
            gradient_mag = np.sqrt(dx**2 + dy**2)

            # Адаптивный порог для Canny на основе перцентилей
            p_low = np.percentile(gradient_mag, 25)
            p_high = np.percentile(gradient_mag, 75)

            # Детектор краев Canny
            edges = feature.canny(
                gradient_mag,
                sigma=self.canny_sigma,
                low_threshold=p_low,
                high_threshold=p_high
            )

            # Морфологическое замыкание для улучшения связности линий
            return morphology.binary_closing(edges, disk(2))
        except Exception as e:
            print(f"Ошибка детектирования границ: {e}")
            return np.zeros_like(dem, dtype=bool)

    def _vectorize_edges(self, edges: np.ndarray) -> gpd.GeoDataFrame:
        """Векторизация бинарного изображения границ в линии с помощью преобразования Хафа."""
        try:
            # Параметры для вероятностного преобразования Хафа
            hough_params = {
                'threshold': 50,
                'line_length': self.min_length,
                'line_gap': 10,
                'theta': np.linspace(-np.pi/2, np.pi/2, 90)  # Шаг 1 градус
            }

            # Детекция прямых линий
            lines = transform.probabilistic_hough_line(edges, **hough_params)

            features = []
            for line in lines:
                p0, p1 = line
                if self.transform:
                    # Преобразование пиксельных координат в географические
                    x0, y0 = self.transform * (p0[0], p0[1])
                    x1, y1 = self.transform * (p1[0], p1[1])
                    line_geom = LineString([(x0, y0), (x1, y1)])
                else:
                    # Если transform не задан, работаем в пиксельных координатах
                    line_geom = LineString([(p0[0], p0[1]), (p1[0], p1[1])])

                # Фильтр по минимальной длине
                if line_geom.length >= self.min_length:
                    features.append(line_geom)

            return gpd.GeoDataFrame(geometry=features, crs=self.crs)

        except Exception as e:
            print(f"Ошибка векторизации: {e}")
            return gpd.GeoDataFrame(geometry=[], crs=self.crs)

    def _postprocess_lines(self, gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """Постобработка линий: объединение и упрощение."""
        if gdf.empty:
            return gpd.GeoDataFrame(geometry=[], crs=self.crs)

        try:
            # Объединение близко расположенных линий
            merged_lines = linemerge(gdf.geometry.tolist())

            processed_geoms = []
            # Обработка результата объединения (может быть LineString или MultiLineString)
            if isinstance(merged_lines, MultiLineString):
                geoms_to_process = list(merged_lines.geoms)
            elif isinstance(merged_lines, LineString):
                geoms_to_process = [merged_lines]
            else:
                geoms_to_process = []

            for line in geoms_to_process:
                try:
                    # Упрощение линии (уменьшение количества точек)
                    simplified_line = line.simplify(self.simplify_tol)
                    if not simplified_line.is_empty:
                        # Расчет минимальной длины в реальных единицах измерения
                        min_length_real = self.min_length * abs(self.transform.a) if self.transform else self.min_length
                        if simplified_line.length >= min_length_real:
                            processed_geoms.append(simplified_line)
                except Exception as e:
                    print(f"Ошибка упрощения линии: {e}")
                    continue

            return gpd.GeoDataFrame(geometry=processed_geoms, crs=self.crs)

        except Exception as e:
            print(f"Ошибка постобработки: {e}")
            return gpd.GeoDataFrame(geometry=[], crs=self.crs)

    def _calculate_stats(self, gdf: gpd.GeoDataFrame) -> Dict:
        """Расчет статистики по обнаруженным линеаментам."""
        if gdf.empty:
            return {
                'total_count': 0,
                'total_length': 0.0,
                'avg_length': 0.0,
                'max_length': 0.0,
                'orientation_bins': (np.array([]), np.array([]))
            }

        try:
            lengths = []
            orientations = []

            for geom in gdf.geometry:
                if not geom.is_empty:
                    lengths.append(geom.length)
                    coords = np.array(geom.coords)
                    if len(coords) >= 2:
                        # Расчет азимута линии
                        dx = coords[-1, 0] - coords[0, 0]
                        dy = coords[-1, 1] - coords[0, 1]
                        angle = np.degrees(np.arctan2(dy, dx)) % 180  # Приведение к диапазону 0-180°
                        orientations.append(angle)

            if not lengths:
                return {
                    'total_count': 0,
                    'total_length': 0.0,
                    'avg_length': 0.0,
                    'max_length': 0.0,
                    'orientation_bins': (np.array([]), np.array([]))
                }

            # Построение розы-диаграммы направлений (12 секторов по 15°)
            hist, bin_edges = np.histogram(orientations, bins=np.linspace(0, 180, 13)) if orientations else (np.array([]), np.array([]))

            return {
                'total_count': len(lengths),
                'total_length': float(np.sum(lengths)),
                'avg_length': float(np.mean(lengths)),
                'max_length': float(np.max(lengths)),
                'orientation_bins': (hist, bin_edges)
            }

        except Exception as e:
            print(f"Ошибка расчета статистики: {e}")
            return {
                'total_count': 0,
                'total_length': 0.0,
                'avg_length': 0.0,
                'max_length': 0.0,
                'orientation_bins': (np.array([]), np.array([]))
            }

    def process(self, input_raster: str,
                output_shp: Optional[str] = None,
                output_png: Optional[str] = None) -> Tuple[Optional[gpd.GeoDataFrame], Dict]:
        """
        Основной метод обработки растрового файла.

        Параметры:
        input_raster - путь к входному растру (GeoTIFF)
        output_shp - путь для сохранения шейп-файла (опционально)
        output_png - путь для сохранения визуализации (опционально)

        Возвращает:
        Кортеж (GeoDataFrame с линеаментами, статистика)
        """
        try:
            dem = part1

            # Обработка данных
            processed_dem = self._preprocess_dem(dem)
            edges = self._detect_edges(processed_dem)
            raw_lines = self._vectorize_edges(edges)
            final_lines = self._postprocess_lines(raw_lines)
            stats = self._calculate_stats(final_lines)

            # Сохранение результатов в шейп-файл (если указан путь)
            if output_shp and not final_lines.empty:
                try:
                    final_lines.to_file(output_shp)
                    print(f"Шейп-файл сохранен: {output_shp}")
                except Exception as e:
                    print(f"Ошибка сохранения шейп-файла: {e}")

            # Визуализация и сохранение изображения (если указан путь)
            if output_png:
                try:
                    fig, ax = plt.subplots(figsize=(12, 12))
                    # Отображение исходной ЦМР
                    show(dem, ax=ax, cmap='terrain')
                    # Отображение линеаментов поверх
                    if not final_lines.empty:
                        final_lines.plot(ax=ax, color='red', linewidth=1.5)

                    ax.set_title(f"Линеаменты (N={stats['total_count']}, L={stats['total_length']:.1f} м)")
                    plt.savefig(output_png, dpi=300, bbox_inches='tight')
                    plt.close()
                    print(f"Изображение сохранено: {output_png}")
                except Exception as e:
                    print(f"Ошибка визуализации: {e}")
                    plt.close('all')

            return final_lines, stats

        except Exception as e:
            print(f"Критическая ошибка обработки: {e}")
            return None, {
                'total_count': 0,
                'total_length': 0.0,
                'avg_length': 0.0,
                'max_length': 0.0,
                'orientation_bins': (np.array([]), np.array([]))
            }

# Пример использования
if __name__ == "__main__":
    # Создаем детектор
    detector = LineamentDetector(
        min_length_pixels=10,
        canny_sigma=1.0,
        simplify_tolerance=2.0
    )

    # Запускаем обработку
    lineaments, statistics = detector.process(
        input_raster=part1,  # Укажите путь к вашему файлу
        output_shp="output_lineaments_CHUKOTKA_ALOS_1.shp",
        output_png="output_lineaments_CHUKOTKA_ALOS_1.png"
    )

    # Выводим статистику
    print(f"Найдено линеаментов: {statistics['total_count']}")
    print(f"Общая длина: {statistics['total_length']:.2f} м")
    print(f"Средняя длина: {statistics['avg_length']:.2f} м")